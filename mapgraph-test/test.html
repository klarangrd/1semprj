<!-- HTML Document Structure -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map graph test</title>

    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://unpkg.com/@turf/turf@6.3.0"></script>
</head>

<body>

    <h1>Map of the Caribbean</h1>

    <!-- Year Selection Dropdown -->
    <label for="chooseYear">Choose Year:</label>
    <select id="chosenYear"></select>

    <!-- Search Button -->
    <button onclick="selectedYear()">Search</button>

    <!-- Zoom In/Out Buttons -->
    <button onclick="zoominout(true)">+</button>
    <button onclick="zoominout(false)">-</button>

    <!-- JavaScript Section -->
    <script>
        // Map Dimensions and Data
        const w = 1000;
        const h = 500;
        let zoom = 1400;
        let bubbleData;

        // Function for Zooming In/Out on the Map
        function zoominout(zoomin) { //zoom in and out function on map
            if (zoomin === true) {
                zoom += 100;
                updateMap();
            } else if (zoomin === false && zoom > 1400) {
                zoom -= 100;
                updateMap();
            }
        }

        // Function to Update the Map with Filtered Data
        function updateMap(filterData) {
            //define Map Projection
            const projection = d3.geoMercator()
                .center([-75, 18])
                .scale(zoom)
                .translate([w / 2, h / 2]);

            //create Path Generator
            const path = d3.geoPath().projection(projection);

            //update Geojson Paths
            d3.selectAll("path")
                .attr("d", path);
            //update Circles with Filtered Data

// check if filterData is provided
if (filterData) {
    // update circles with filtered data

    // select all circles and bind data
    d3.selectAll("circle")
        .data(filterData)
        .join(
            // enter: append new circles for new data
            enter => enter.append("circle"),
            // update: keep existing circles for updated data
            update => update,
            // exit: remove excess circles for removed data
            exit => exit.remove()
        )
        // set the x-coo of circles based on longitude
        .attr("cx", d => projection([d.longitude, d.latitude])[0])
        // set the y-coo of circles based on latitude
        .attr("cy", d => projection([d.longitude, d.latitude])[1])
        // set the r of circles
        .attr("r", 4)
        // set the fill colour of circles
        .style("fill", "red")
        // set the opacity of circles
        .style("opacity", 0.5);
} else {
    // remove all circles when no filter data is provided
    d3.selectAll("circle").remove();
}
            //fetch and Generate Geojson Data
            d3.json("c2.json").then(function (data) {
                generate(filterData, data);
            });
        }

        //svg Container for the Map
        const svg = d3.select("body")
            .append("svg")
            .attr("width", w)
            .attr("height", h)
            .style("background-color", "lightblue");

        //fetch Geojson and Database JSON
        Promise.all([
            d3.json("c2.json"),
            d3.json("http://localhost:3000/kordinater")
        ]).then(function (data) {
            const geojson = data[0];
            bubbleData = data[1].LionfishCloud; //collecting the LionfishCloud database

            //generate Map with Initial Data
            generate(bubbleData, geojson);
        });

        //function to Generate Map Elements
        function generate(bubbleData, geojson) {
            //parse Latitude and Longitude in Bubble Data
            parseData(bubbleData);

            //define Map Projection
            const projection = d3.geoMercator()
                .center([-75, 18])
                .scale(zoom)
                .translate([w / 2, h / 2]);

            //create Path Generator
            const path = d3.geoPath().projection(projection);

            //draw Geojson Paths
            svg.selectAll("path")
                .data(geojson.features)
                .enter()
                .append("path")
                .attr("d", path)
                .style("fill", "green");

            //draw Circles for Bubble Data
            svg.selectAll("circle")
                .data(bubbleData)
                .enter()
                .append("circle")
                .attr("cx", d => projection([d.longitude, d.latitude])[0])
                .attr("cy", d => projection([d.longitude, d.latitude])[1])
                .attr("r", 4)
                .style("fill", "red")
                .style("opacity", 0.5);

            //populate the dropdown with years
            populateDropdown(bubbleData);
        }

        //function to Parse Latitude and Longitude in Bubble Data
        function parseData(bubbleData) {
            for (let n in bubbleData) {
                bubbleData[n].latitude = parseFloat(bubbleData[n].latitude);
                bubbleData[n].longitude = parseFloat(bubbleData[n].longitude);
            }
        }

        //function to Populate Dropdown with Unique Years
        function populateDropdown(bubbleData) {
            const dropdown = document.getElementById('chosenYear');

            //taking unique years from the dataset
            const years = [...new Set(bubbleData.map(item => item.year))];

            //putting the year as the dropdown menu
            years.forEach(year => {
                const option = document.createElement('option');
                option.value = year;
                option.text = year;
                dropdown.add(option);
            });
        }

        //function to Handle Year Selection
        function selectedYear() {
            const selectedYear = document.getElementById('chosenYear').value;
            const filteredBubbleData = (selectedYear === 'ALL') ?
                bubbleData :
                bubbleData.filter(d => d.year == selectedYear);

            //update the Map with Filtered Data
            updateMap(filteredBubbleData);
        }
    </script>
</body>

</html>
