<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map graph test</title>
    <!-- Include D3.js and Turf.js libraries -->
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://unpkg.com/@turf/turf@6.3.0"></script>
</head>

<body>
    <h1>Map of the Caribbean</h1>

    <label for="chooseYear">Choose Year:</label>
    <select id="chosenYear"></select>

    <button onclick="selectedYear()">Search</button>

    <button onclick="zoominout(true)">+</button>
    <button onclick="zoominout(false)">-</button>

    <script>
        const w = 1000;
        const h = 500;
        let zoom = 1400;
        let bubbleData;

        function zoominout(zoomin) { //zoom in and out function on map
            if (zoomin === true) {
                zoom += 100;
                updateMap();
            } else if (zoomin === false && zoom > 1400) {
                zoom -= 100;
                updateMap();
            }
        }

        function updateMap(filterData) {
            const projection = d3.geoMercator()
                .center([-75, 18])
                .scale(zoom)
                .translate([w / 2, h / 2]);

            const path = d3.geoPath().projection(projection);

            d3.selectAll("path")
                .attr("d", path);

            if (filterData) {
                // Update circles with filtered data
                d3.selectAll("circle")
                    .data(filterData)
                    .join(
                        enter => enter.append("circle"),
                        update => update,
                        exit => exit.remove()
                    )
                    .attr("cx", d => projection([d.longitude, d.latitude])[0])
                    .attr("cy", d => projection([d.longitude, d.latitude])[1])
                    .attr("r", 4)
                    .style("fill", "red")
                    .style("opacity", 0.5);
            } else {
                // Remove all circles when no filter data is provided
                d3.selectAll("circle").remove();
            }

            d3.json("c2.json").then(function (data) {
                generate(filterData, data);
            });
        }

        const svg = d3.select("body")
            .append("svg")
            .attr("width", w)
            .attr("height", h)
            .style("background-color", "lightblue");

        Promise.all([ //fetching geojson and json with the database
            d3.json("c2.json"),//caribbean and south usa data
            d3.json("http://localhost:3000/kordinater") //coordinates for the lionfish found per year
        ]).then(function (data) {
            const geojson = data[0];
            bubbleData = data[1].LionfishCloud;//collecting the database LionfishCloud

            generate(bubbleData, geojson);
        });

        function generate(bubbleData, geojson) {
            parseData(bubbleData);

            const projection = d3.geoMercator()
                .center([-75, 18])
                .scale(zoom)
                .translate([w / 2, h / 2]);

            const path = d3.geoPath().projection(projection);

            svg.selectAll("path")
                .data(geojson.features)
                .enter()
                .append("path")
                .attr("d", path)
                .style("fill", "green");

            svg.selectAll("circle")
                .data(bubbleData)
                .enter()
                .append("circle")
                .attr("cx", d => projection([d.longitude, d.latitude])[0])
                .attr("cy", d => projection([d.longitude, d.latitude])[1])
                .attr("r", 4)
                .style("fill", "red")
                .style("opacity", 0.5);

            // populate the dropdown with years
            populateDropdown(bubbleData);
        }

        function parseData(bubbleData) {
            for (let n in bubbleData) {
                bubbleData[n].latitude = parseFloat(bubbleData[n].latitude);
                bubbleData[n].longitude = parseFloat(bubbleData[n].longitude);
            }
        }

        function populateDropdown(bubbleData) {
            const dropdown = document.getElementById('chosenYear');

            // taking unique years from the dataset
            const years = [...new Set(bubbleData.map(item => item.year))];

            // putting the year as the dropdown menu
            years.forEach(year => {
                const option = document.createElement('option');
                option.value = year;
                option.text = year;
                dropdown.add(option);
            });
        }

        function selectedYear() {
            const selectedYear = document.getElementById('chosenYear').value;
            const filteredBubbleData = (selectedYear === 'ALL') ?
                bubbleData :
                bubbleData.filter(d => d.year == selectedYear);

            updateMap(filteredBubbleData);
        }
    </script>
</body>

</html>
